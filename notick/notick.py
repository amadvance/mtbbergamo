#!/usr/bin/python3
#
# Remove GoPro noisy ticks generated by unstable mounting accessories
#
# They are identified as 10ms noise with a main frequency
# component at 1150 Hz.
#
# When found, the tick is replaced with the previous 10ms window.
#
# The tool is able to process only .wav files. You need to extract
# the audio track, process it, and then add it again into the video.
#
# Like this:
#
# ffmpeg -i XXX.mp4 -vn -acodec pcm_s16le XXX.wav
# python3 notick.py XXX.wav XXX_notick.wav
# ffmpeg -i XXX.mp4 -i XXX_notick.wav -c:v copy -map 0:v:0 -map 1:a:0 XXX_notick.mp4
#

import sys
import wave
import struct
import math
import numpy as np

global data
global hamming

#
# Clear tick at the specified position
# The data before the tick position is copied over the tick with a trapezoidal window
#
# It's assumed a window size of 512
#
def clear_tick(pos):
	if pos < 512:
		return

	for i in range(0,63):
		j = (pos + i)*2
		l = i
		r = 64 - l
		data[j] = (data[j] * r + data[j-1024] * l) // 64
		data[j+1] = (data[j+1] * r + data[j-1024+1] * l) // 64

	for i in range(64,447):
		j = (pos + i)*2
		data[j] = data[j-1024]
		data[j+1] = data[j-1024+1]

	for i in range(448,511):
		j = (pos + i)*2
		l = i - 448
		r = 64 - l
		data[j] = (data[j] * l + data[j-1024] * r) // 64
		data[j+1] = (data[j+1] * l + data[j-1024+1] * r) // 64


#
# Analyze a sample window
#
# It's assumed a window size of 512
#
# Note that with a 48000 sample rate, the 512 sample analysis
# covers 10.6ms.
#
# Return the power of the tick and of the rest of signal.
#
def process(sample):
	scaled = [x*y for x, y in zip(sample, hamming)]

	dft = np.fft.fft(scaled)

	power_other = 0
	power_tick = 0
	for i in range(1, 10):
		power_other += abs(dft[i])
	for i in range(11, 14):
		power_tick += abs(dft[i])
	for i in range(15, 127):
		power_other += abs(dft[i])

	# avoid division by 0
	if power_other < 0.001:
		power_other = 0.001;

	return (power_other,power_tick)


if len(sys.argv) != 3:
	print("Syntax: notick SRC.wav DST.wav")
	exit(1)

inp = wave.open(sys.argv[1],'rb')

if inp.getnchannels() != 2:
	print("Only 2 channel WAV are supported")
	exit(1)

if inp.getsampwidth() != 2:
	print("Only 16 bit WAV are supported")
	exit(1)

if inp.getframerate() != 48000:
	print("Only 48000 Hz WAV are supported")
	exit(1)

count = inp.getnframes()

frame = inp.readframes(count);

data = list(struct.unpack("<%dh" % (count*2), frame))

inp.close()

left_channel = []
for i in data[::2]:
	left_channel.append(i / 32768.0)

right_channel = []
for i in data[1::2]:
	right_channel.append(i / 32768.0)

pos = 0
peak_ratio = 0
peak_pos = 0
peak_volume = 0

# use an hamming window on the input
hamming = np.hamming(512)

clear_count = 0
for pos in range(0, count - 512, 16):
	if pos % 100000 == 0:
		print("%d%%" % (100 * pos // count))
		sys.stdout.flush()

	(power_other, power_tick) = process(left_channel[pos:pos+511])

	ratio = power_tick / power_other
	if ratio > peak_ratio:
		peak_ratio = ratio
		peak_pos = pos
		peak_volume = power_tick

	(power_other, power_tick) = process(right_channel[pos:pos+511])

	ratio = power_tick / power_other
	if ratio > peak_ratio:
		peak_ratio = ratio
		peak_pos = pos
		peak_volume = power_tick

	if peak_ratio > 0.4 and pos - peak_pos > 512:
		pos_msec = peak_pos * 1000 // inp.getframerate()
		pos_sec = pos_msec // 1000
		pos_msec = pos_msec % 1000
		clear_count = clear_count + 1
		print("tick %d:%02d.%03d, ratio %.2f, volume %.2f" % (pos_sec / 60, pos_sec % 60, pos_msec, peak_ratio, peak_volume))
		sys.stdout.flush()
		clear_tick(peak_pos)
		peak_pos = 0
		peak_ratio = 0
		peak_volume = 0

out = wave.open(sys.argv[2], 'wb')
out.setnchannels(2)
out.setsampwidth(2)
out.setframerate(48000)
out_data = struct.pack('<%dh' % (count*2), *data)
out.writeframes(out_data)
out.close()

print("tick_cleared", clear_count)
